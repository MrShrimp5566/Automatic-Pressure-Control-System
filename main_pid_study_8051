/*
 * main_pid_study_8051.c
 * ------------------------------------------------------------
 * Runs tiny, trusted inference on the 8051 (Keil) to classify
 * pre/post Ziegler–Nichols tuning for your secondary tank.
 *
 * C89/ANSI C compliant version for older Keil C51 compilers.
 */
#include <reg51.h>      // Keil SFRs for classic 8051
#include "pc_model.h"   // Exported arrays + FEAT_MIN/MAX + MODEL_CRC16

int integral = 0;
int prev_error = 0;
int simulated_pressure = 50;
int valve_control = 0;

// --- Add these new simulation functions ---
int read_pressure_sensor(void) {
    // In a real system, this would read from an ADC.
    // For our simulation, it just returns the current virtual pressure.
    return simulated_pressure;
}

void drive_valve(int control_signal) {
    // In a real system, this would control a PWM output.
    // For our simulation, we just store the value.
    valve_control = control_signal;
}

int PID_update(int error) {
    int Kp = 2;  // Proportional gain (start with simple values)
    int Ki = 1;  // Integral gain
    int Kd = 1;  // Derivative gain
    
    int derivative;
    int control_output;

    integral = integral + error;
    derivative = error - prev_error;
    
    control_output = (Kp * error) + (Ki * integral) + (Kd * derivative);
    
    prev_error = error;
    
    return control_output;
}
// ---------- (Optional) CRC16-CCITT recompute for trusted inference ----------
static unsigned int crc16_ccitt_update(unsigned int crc, unsigned char byte) {
    /* C89 Compliance: Declare variables at the top of the function */
    unsigned char i;

    crc ^= (unsigned int)byte << 8;
    for (i = 0; i < 8; i++) {
        crc = (crc & 0x8000) ? (unsigned int)((crc << 1) ^ 0x1021) : (unsigned int)(crc << 1);
    }
    return (unsigned int)(crc & 0xFFFF);
}

static unsigned int model_crc16_recompute(void) {
    /* C89 Compliance: Declare all variables at the top of the function */
    unsigned int crc = 0xFFFF;
    int i;
    unsigned int v;

    // Pack feat|thresh|cleft|cright|value exactly as Python did:
    
    // CORRECTED PART: Handle the 'feat' array properly
    for (i = 0; i < NODES; i++) {
        crc = crc16_ccitt_update(crc, (unsigned char)feat[i]); 
    }
    
    for (i = 0; i < NODES; i++) {
        crc = crc16_ccitt_update(crc, (unsigned char)thresh[i]);
    }
    for (i = 0; i < NODES; i++) {
        v = (unsigned int)cleft[i];
        crc = crc16_ccitt_update(crc, (unsigned char)(v & 0xFF));
        crc = crc16_ccitt_update(crc, (unsigned char)((v >> 8) & 0xFF));
    }
    for (i = 0; i < NODES; i++) {
        v = (unsigned int)cright[i];
        crc = crc16_ccitt_update(crc, (unsigned char)(v & 0xFF));
        crc = crc16_ccitt_update(crc, (unsigned char)((v >> 8) & 0xFF));
    }
    for (i = 0; i < NODES; i++) {
        crc = crc16_ccitt_update(crc, (unsigned char)value[i]);
    }
    return crc;
}

// ---------- Non-recursive Decision Tree traversal (stack-safe) ----------
static unsigned char classify_pid_state(const unsigned char *features) {
    /* C89 Compliance: Declare all variables at the top of the block */
    int node = 0;
    char f;
    unsigned char x;
    unsigned char th;

    for (;;) {
        f = feat[node];                          // feature index or -2 for leaf
        if (f == -2) return value[node];         // leaf → majority class (0/1)
        x  = features[(unsigned char)f];         // pick feature
        th = thresh[node];                       // threshold
        node = (x <= th) ? cleft[node] : cright[node];  // branch without recursion
    }
}

// ---------- Example main() ----------
void main(void) {
    /* C89 Compliance: Declare all variables at the top of the function */
    int current_pressure;
    int pressure_setpoint = 100; // Our target pressure
    int error;
    int control_signal;

    // The main control loop that runs forever
    while (1) {
        // 1. Read the sensor
        current_pressure = read_pressure_sensor();

        // 2. Calculate the error
        error = pressure_setpoint - current_pressure;
        
        // 3. Compute the control signal using the PID algorithm
        control_signal = PID_update(error);
        
        // 4. Drive the valve with the new signal
        drive_valve(control_signal);
        
        // 5. Update our simple tank simulation model
        //    (Pressure increases with valve opening and decreases with a constant "leak")
        simulated_pressure = simulated_pressure + (valve_control / 10) - 5;
    }
}
